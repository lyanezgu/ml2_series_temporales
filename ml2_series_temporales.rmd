---
title: "ML2 - Time Series"
author: "Luisa Yanez y Miguel García"
date: "08/07/2022"
output: 
 html_document:
  code_folding: hide
  toc: yes
  toc_float: TRUE
  toc_depth: 3 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

# ML2 - Series Temporales

# 1. Introducción

## 1.1. Lenguaje de programación y herramienta de control de versiones utilizado
**Link del proyecto en GitHub:**
https://github.com/lyanezgu/ml2_series_temporales

## 1.2. Paquetes de R

```{r librerias, include=TRUE, message=FALSE, warning = FALSE,tidy=TRUE, tidy.opts=list(width.cutoff=60)}
library(readr)
library(tidyverse)
library(tsibble)
library(fable)
library(feasts)
library(tsibbledata)
library(VIM)
library(Amelia)
library(imputeTS)
library(gridExtra)
library(dygraphs)
library(ggfortify)
library(vars)
library(ggplot2)
library(lubridate)
library(assertthat)
library(xts)
library(MASS)
library(fpp3)
library(GGally)
library(forecast)
library(tseries)

```

# 2. Conjunto de datos 

**Link del dataset:**
https://www.kaggle.com/datasets/sumanthvrao/daily-climate-time-series-data?resource=download&select=DailyDelhiClimateTest.csv


## 2.1. Definición de las variables

* **Date:** fecha en formato YYYY-MM-DD

* **meantemp:** temperatura media calculada en intervalos de tres horas por día

* **humidity:** humedad en el día gramos de vapor de agua por volumen en m3 de aire

* **wind_speed:** velocidad del aire medido en km/h

* **meanpreassure:** presión medida en atm


## 2.2. Carga de datos

Cargamos los datos ya dividos entre train y test
```{r  }
clima_train<-read.csv("DailyDelhiClimateTrain.csv",sep = ",")
clima_test<-read.csv("DailyDelhiClimateTest.csv",sep = ",")


```


```{r}
head(clima_train)

```


```{r}
summary(clima_train)

```

```{r}
str(clima_train)

```


Transformamos formato de variable date de chr a fecha

```{r}
clima_train$date<-as.Date(clima_train$date)
str(clima_train)
```

```{r}
clima_test$date<-as.Date(clima_test$date)
str(clima_test)
```


Seleccionamos la variable meantemp relativa a la temperatura media en Delhi, que será la que intentaremos predecir.

```{r}
temp_train <- clima_train[,c(1,2)]
head(temp_train)
```


Creamos el objeto de series temprales  con la función as_tsibble
```{r}
temp_train_ts<- as_tsibble(temp_train, index = date)

temp_train_ts

```


Grafico de la serie temporal de la variable meantemp

```{r}

temp_train_ts %>%
  autoplot(meantemp) +
    labs(title = "Temperatura media Delhi 2013-2017") +
    xlab("Años") + ylab("Temperatura") 

```

# 3. Análisis de la serie temporal 

## 3.1. Estacionariedad

Observando el gráfico parece que hay una componente estacional anual, ya que la forma de las series anuales son iguales.

```{r}
temp_train_ts%>%
gg_season(meantemp, labels = "right")

```
Calculamos la descomposición STL para observar si existe tendencia y estacionalidad.
Gráficamente se puede comprobar que existe estacionalidad y una tendencia creciente.Por tanto, parece se puede decir que la serie no es estacionaria en media.

```{r}
temp_train_ts %>%
   model(seats = feasts:::STL(meantemp)) %>%
  components() %>%
  autoplot()

```

### 3.1.1. Estacionariedad en Varianza

Estudiamos la estacionariedad en varianza. Dado que obtenemos un valor muy próximo a 1, no realizaremos ningún cambio o transformación para ajustar la varianza.

```{r}
lambda <- temp_train_ts %>%
features(meantemp, features = guerrero) %>% pull(lambda_guerrero)
lambda

```

### 3.1.2. Estacionariedad en Media

Comprobamos la estacionariedad en media usando una prueba de raíces unitarias.

```{r}
temp_train_ts %>%
  features(meantemp, unitroot_kpss)


``` 

El p-valor es menor que 0.05, lo que indica que la hipótesis nula es rechazada. Es decir, los datos no son estacionarios en media. Se confirma formalmente que los datos no son estacionarios.


Para estabilizar la media usamos una diferencia y lo comprobamos con el siguiente test.
Obtenemos un p_value mayor de 0.05 por lo que cumpliría la hipótesis de estacionariedad y podemos realizar una diferencia regular para eliminar la tendencia.

```{r}
temp_train_ts %>%
  features(difference(meantemp, 1), unitroot_kpss)

```


```{r}
temp_train_ts %>% autoplot(difference(meantemp, 1)) 

```


Para evaluar si es necesario realizar una diferencia estacional debido a que los datos presentan estacionalidad usaremos unitroot_nsdiffs(). Debido a que es menor a 0.64 el método no sugiere una diferencia estacional.

```{r}
temp_train_ts %>%
  mutate(turnover = difference(meantemp,1)) %>%
  features(turnover, unitroot_nsdiffs)

```


## 3.2. Creación del modelo (determinación, estimación y contraste)

```{r}
# Contraste para los coeficientes
my_t_test <- function (object, ...) 
{
  par <- rbind(t_stat=tidy(object)$statistic, p_value=tidy(object)$p.value)
  colnames(par) <- tidy(object)$term
  if (NCOL(par) > 0) {
    cat("\nt-test:\n")
    coef <- round(par, digits = 4)
    print.default(coef, print.gap = 2)
  }
}

# Gráfico de correlogramas de residuos
my_tsresiduals <- function (data, ...) {
  if (!fabletools::is_mable(data)) {
    abort("gg_tsresiduals() must be used with a mable containing only one model.")
  }
  data <- stats::residuals(data)
  if (n_keys(data) > 1) {
    abort("gg_tsresiduals() must be used with a mable containing only one model.")
  }
  gg_tsdisplay(data, !!sym(".resid"), plot_type = "partial",  
    ...)
}

# Validación cruzada anidada

nested_cv <- function(df, h, last_train, string_formula){
  
  nested_errors <- vector()  
  
for (i in seq(last_train, last(df$date), h)){
  train <- df %>% filter(date<=i)
  test <- df %>% filter(date>i)
  
fitted_model <- train %>%
  model(arima = ARIMA(as.formula(string_formula)))

h_forecast = min(dim(test)[1], h)

fc <- fitted_model %>%
  forecast(h=h_forecast)

test_err <- fc %>%
  accuracy(test) %>%
  select(MAPE)
nested_errors <- c(nested_errors, test_err$MAPE)
NewList <- list("errors"=nested_errors, "mean"=mean(nested_errors))
}
return(NewList)}

# Test de autocorrelacines de los residuos
autocorrelation_test_plot <- function(aug, dof = 4, m = 7,  h = 5, alpha = 0.05){
vec <- c()
num_lags = seq(1, h*m)

for (i in num_lags){
 vec <- c(vec,aug %>% features(.resid, ljung_box, lag=i, dof=dof) %>% .$lb_pvalue)
}

autocorr_pvalues_resid <- tibble(
  lag = num_lags, 
  p_value = vec,
  incorelated = p_value >= alpha
)

plot <- autocorr_pvalues_resid %>% 
  drop_na() %>% 
   ggplot(aes(lag, p_value, color = incorelated)) + 
  geom_point() + 
  geom_hline(aes(yintercept = alpha), linetype="dashed", color = "indianred2")


newList <- list("values" = autocorr_pvalues_resid, "plot" = plot)
return(newList)
}


```


### 3.2.1. Creación manual del modelo

```{r}
fit <- temp_train_ts %>%
  model(arima = ARIMA(meantemp ~ pdq(0,1,0) + PDQ(0,1,0, period = 7)))
fit %>% my_tsresiduals(lag_max = 36)

```


```{r}
fit2 <- temp_train_ts %>%
  model(arima = ARIMA(meantemp ~ pdq(3,1,1) + PDQ(0,1,1, period = 7)))
fit2 %>% my_tsresiduals(lag_max = 36)

```


```{r}
fit3 <- temp_train_ts %>%
  model(arima = ARIMA(meantemp ~ pdq(0,1,0) + PDQ(0,0,0, period = 7)))
fit3 %>% my_tsresiduals(lag_max = 36)

```


```{r}
report(fit2)

```


```{r}
my_t_test(fit2)

```

### 3.2.2. Creación automática del modelo

```{r}
#ajuste del modelo automatica

autoarima_model<- auto.arima(temp_train_ts)
autoarima_model
```

```{r}

fit4 <- temp_train_ts %>%
  model(arima = ARIMA(meantemp ~ pdq(3,1,2) + PDQ(1,0,0, period = 7)))
fit4 %>% my_tsresiduals(lag_max = 36)

```

```{r}
report(fit4)

```


```{r}
my_t_test(fit4)

```

```{r}

gg_arma(fit4)

``` 

## 3.3. Diagnosis de residuos

```{r}
aug <-fit4 %>% augment()

# Histogram
aug %>%
  ggplot(aes(x = .resid)) +
  geom_histogram(bins = 50) +
  ggtitle("Histogram of residuals")


``` 

```{r}
t.test(aug$.resid)

```


Test autocorrelaciones

```{r}
aug %>% features(.resid, ljung_box, lag=24, dof=2)

```

```{r}
pvals = autocorrelation_test_plot(aug, m = 12, dof = 2, h = 2, alpha = 0.05)

```

```{r}
pvals

```


Test homocedasticidad

```{r}
log_log <- aug %>% as_tibble() %>% 
  group_by(week(date)) %>% 
  summarize(mean_resid = log(mean(.resid+1)), std_resid = log(sd(.resid+1))) 

```

```{r}
summary(lm(std_resid~mean_resid, log_log))

```

Test de normalidad

```{r}
#shapiro.test(rstandard(aug$.resid))

```


## 3.4. Predicción con el modelo

```{r}
clima_total<-merge(x=clima_train,y=clima_test,all = TRUE)
head(clima_total)
```

```{r}
temp_total <- clima_total[,c(1,2)]
head(temp_total)

temp_total_ts<- as_tsibble(temp_total, index = date)

temp_total_ts

```

```{r}
# Residual accuracy
resids <- fit4 %>% 
  accuracy() %>% 
  dplyr::select(-c(.model, .type, ME, MPE, ACF1, RMSSE)) %>% 
  mutate(Evaluation='Training') 

# Forecasting
fc <- fit4 %>%
  forecast(h=7) 

test_err <- fc %>% 
  accuracy(temp_total_ts) %>% 
  dplyr::select(-c(.model, .type, ME, MPE, ACF1, RMSSE)) %>% 
  mutate(Evaluation='Test')

# Show errors together
bind_rows(test_err, resids) %>% dplyr::select(Evaluation, everything())

``` 


```{r}
aug %>%  ggplot() +
  geom_line(aes(x = date, y = .fitted), color="navy") +
  geom_line(aes(x = date, y = meantemp), color="gray24") +
  # geom_line(data=demandaGas_forecast, aes(x = index, y = value), color="red4") +
  ggtitle("SARIMA train fitted values") +
  xlab('Dates') +
  ylab('Demand') + facet_wrap(vars(year(date)), scales = 'free')

``` 


```{r}
aug %>% filter(year(date) == 2013) %>% 
  ggplot() +
  geom_line(aes(x = date, y = .fitted), color="navy") +
  geom_line(aes(x = date, y = meantemp), color="gray24") +
  # geom_line(data=demandaGas_forecast, aes(x = index, y = value), color="red4") +
  ggtitle("SARIMA train fitted values") +
  xlab('Dates') +
  ylab('Demand') + facet_wrap(vars(month(date)), scales = 'free')
```


```{r}
temp_test <- clima_test[,c(1,2)]
head(temp_train)

temp_test_ts<- as_tsibble(temp_test, index = date)

temp_test_ts
```

```{r}
h <- dim(temp_test_ts)[1]

demanda_plot <- temp_total_ts %>% filter(date>last(temp_train_ts$date)-14 & date< last(temp_train_ts$date) + 7 )

fit4 %>%
  forecast(h=7) %>%
  autoplot(demanda_plot)

```


