---
title: "ml2_series_temporales"
author: "luisa"
date: "22/6/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# ML2 - Series Temporales

# 1. Introducción
## 1.1. Lenguaje de programación y herramienta de control de versiones utilizado
**Link del proyecto en GitHub:**
https://github.com/lyanezgu/ml2_series_temporales

## 1.2. Paquetes de R

```{r}
library(readr)
library(tidyverse)
library(tsibble)
library(fable)
library(feasts)
library(tsibbledata)
packages =  c("ggplot2", "dplyr", "tidyr", "data.table", 'corrplot', 'gridExtra', 'forecast', 'tseries', 'TSA', 'tibble', 'TTR', 'xts', 'dygraphs', 'assertthat')
#library(normtest)
library(VIM)
library(Amelia)
library(imputeTS)
library(gridExtra)
library(dygraphs)
library(ggfortify)
library(vars)
library(ggplot2)
library(lubridate)
library(assertthat)
library(xts)
library(MASS)
library(fpp3)
library(GGally)
#ibrary(normtest)

```

# 2. Conjunto de datos 

**Link del dataset:**
https://www.kaggle.com/datasets/sumanthvrao/daily-climate-time-series-data?resource=download&select=DailyDelhiClimateTest.csv


## 2.1. Definición de las variables

Date: fecha en formato YYYY-MM-DD

meantemp: temperatura media calculada en intervalos de tres horas por día

humidity: humedad en el día gramos de vapor de agua por volumen en m3 de aire

wind_speed: velocidad del aire medido en km/h

meanpreassure: presión medida en atm


## 2.2. Carga de datos

Cargamos los datos ya dividos entre train y test
```{r  }
clima_train<-read.csv("DailyDelhiClimateTrain.csv",sep = ",")
clima_test<-read.csv("DailyDelhiClimateTest.csv",sep = ",")


```

```{r}

head(clima_train)

```


```{r}
summary(clima_train)
```



```{r}
str(clima_train)

```


Transformamos formato de variable date de chr a fecha
```{r}
clima_train$date<-as.Date(clima_train$date)
str(clima_train)
```

Seleccionamos la variable meantemp relativa a la temperatura media en Delhi, que será la que intentaremos predecir.
```{r}
temp_train <- clima_train[,c(1,2)]
head(temp_train)
```

Creamos el objeto de series temprales  con la función as_tsibble
```{r}

temp_train_ts<- as_tsibble(temp_train, index = date)

temp_train_ts

```

Grafico de la serie temporal de la variable meantemp

```{r}

temp_train_ts %>%
  autoplot(meantemp) +
    labs(title = "Temperatura media Delhi 2013-2017") +
    xlab("Años") + ylab("Temperatura") 

```

# 3. Análisis de la serie temporal 

## 3.1 Estacionariedad

Observando el gráfico parece que hay una componente estacional anual, ya que la forma de las series anuales son iguales.

```{r}
temp_train_ts%>%
gg_season(meantemp, labels = "right")

```
Calculamos la descomposición STL para observar si existe tendencia y estacionalidad.
Gráficamente se puede comprobar que existe estacionalidad y una tendencia creciente.Por tanto, parece se puede decir que la serie no es estacionaria en media.

```{r}
temp_train_ts %>%
   model(seats = feasts:::STL(meantemp)) %>%
  components() %>%
  autoplot()

```

Estudiamos la estacionariedad en varianza. Dado que obtenemos un valor muy próximo a 1, no realizaremos ningún cambio o transformación para ajustar la varianza.
```{r}
lambda <- temp_train_ts %>%
features(meantemp, features = guerrero) %>% pull(lambda_guerrero)
lambda

```

Comprobamos la estacionariedad en media usando una prueba de raíces unitarias.

```{r}
temp_train_ts %>%
  features(meantemp, unitroot_kpss)


``` 

El p-valor es menor que 0.05, lo que indica que la hipótesis nula es rechazada. Es decir, los datos no son estacionarios en media. Se confirma formalmente que los datos no son estacionarios.


Para estabilizar la media usamos una diferencia y lo comprobamos con el siguiente test.
Obtenemos un p_value mayor de 0.05 por lo que cumpliría la hipótesis de estacionariedad y podemos realizar una diferencia regular para eliminar la tendencia.

```{r}
temp_train_ts %>%
  features(difference(meantemp, 1), unitroot_kpss)

```

```{r}
temp_train_ts %>% autoplot(difference(meantemp, 1)) 

```


Para evaluar si es necesario realizar una diferencia estacional debido a que los datos presentan estacionalidad usaremos unitroot_nsdiffs(). Debido a que es menor a 0.64 el método no sugiere una diferencia estacional.
```{r}
temp_train_ts %>%
  mutate(turnover = difference(meantemp,1)) %>%
  features(turnover, unitroot_nsdiffs)

```


```{r}
# Contraste para los coeficientes
my_t_test <- function (object, ...) 
{
  par <- rbind(t_stat=tidy(object)$statistic, p_value=tidy(object)$p.value)
  colnames(par) <- tidy(object)$term
  if (NCOL(par) > 0) {
    cat("\nt-test:\n")
    coef <- round(par, digits = 4)
    print.default(coef, print.gap = 2)
  }
}

# Gráfico de correlogramas de residuos
my_tsresiduals <- function (data, ...) {
  if (!fabletools::is_mable(data)) {
    abort("gg_tsresiduals() must be used with a mable containing only one model.")
  }
  data <- stats::residuals(data)
  if (n_keys(data) > 1) {
    abort("gg_tsresiduals() must be used with a mable containing only one model.")
  }
  gg_tsdisplay(data, !!sym(".resid"), plot_type = "partial",  
    ...)
}

# Validación cruzada anidada

nested_cv <- function(df, h, last_train, string_formula){
  
  nested_errors <- vector()  
  
for (i in seq(last_train, last(df$date), h)){
  train <- df %>% filter(date<=i)
  test <- df %>% filter(date>i)
  
fitted_model <- train %>%
  model(arima = ARIMA(as.formula(string_formula)))

h_forecast = min(dim(test)[1], h)

fc <- fitted_model %>%
  forecast(h=h_forecast)

test_err <- fc %>%
  accuracy(test) %>%
  select(MAPE)
nested_errors <- c(nested_errors, test_err$MAPE)
NewList <- list("errors"=nested_errors, "mean"=mean(nested_errors))
}
return(NewList)}

# Test de autocorrelacines de los residuos
autocorrelation_test_plot <- function(aug, dof = 4, m = 7,  h = 5, alpha = 0.05){
vec <- c()
num_lags = seq(1, h*m)

for (i in num_lags){
 vec <- c(vec,aug %>% features(.resid, ljung_box, lag=i, dof=dof) %>% .$lb_pvalue)
}

autocorr_pvalues_resid <- tibble(
  lag = num_lags, 
  p_value = vec,
  incorelated = p_value >= alpha
)

plot <- autocorr_pvalues_resid %>% 
  drop_na() %>% 
   ggplot(aes(lag, p_value, color = incorelated)) + 
  geom_point() + 
  geom_hline(aes(yintercept = alpha), linetype="dashed", color = "indianred2")


newList <- list("values" = autocorr_pvalues_resid, "plot" = plot)
return(newList)
}


```

```{r}
fit <- temp_train_ts %>%
  model(arima = ARIMA(meantemp ~ pdq(0,1,0) + PDQ(0,1,0, period = 7)))
fit %>% my_tsresiduals(lag_max = 36)

```


```{r}
fit2 <- temp_train_ts %>%
  model(arima = ARIMA(meantemp ~ pdq(3,1,1) + PDQ(0,1,1, period = 7)))
fit2 %>% my_tsresiduals(lag_max = 36)

```


```{r}
fit3 <- temp_train_ts %>%
  model(arima = ARIMA(meantemp ~ pdq(0,1,0) + PDQ(0,0,0, period = 7)))
fit3 %>% my_tsresiduals(lag_max = 36)

```


```{r}
report(fit2)

```


```{r}
my_t_test(fit2)

```


